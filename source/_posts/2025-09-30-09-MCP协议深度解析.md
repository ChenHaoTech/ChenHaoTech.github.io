---
title: "MCPåè®®æ·±åº¦è§£æ"
date: 2025-09-30 00:00:00
updated: 2025-09-30 19:45:46
categories:
  - å…¶ä»–
tags:
  - claude-note
  - MCPåè®®
  - AIå¼€å‘
  - åè®®è®¾è®¡
  - é€šä¿¡æ¶æ„
permalink: /2025/09/30/mcpåè®®æ·±åº¦è§£æ/
author: é™ˆæµ©
description: "MCPåè®®æ·±åº¦è§£æ..."
date_source: created
original_path: "../public/09-MCPåè®®æ·±åº¦è§£æ.md"
---



# MCPåè®®æ·±åº¦è§£æ

## ğŸ¯ æ¦‚è¿°

MCP (Model Context Protocol) æ˜¯ä¸€ä¸ªé©å‘½æ€§çš„AIå·¥å…·é›†æˆåè®®ï¼Œæ—¨åœ¨ä¸ºAIæ¨¡å‹æä¾›æ ‡å‡†åŒ–çš„ä¸Šä¸‹æ–‡è®¿é—®å’Œå·¥å…·è°ƒç”¨æ¥å£ã€‚é€šè¿‡MCPåè®®ï¼ŒAIåº”ç”¨å¯ä»¥å®‰å…¨ã€é«˜æ•ˆåœ°è®¿é—®å„ç§æ•°æ®æºå’Œæ‰§è¡Œå·¥å…·æ“ä½œï¼Œå®ç°çœŸæ­£çš„AI Agentç”Ÿæ€ã€‚

## ğŸ“‹ MCPåè®®æ ¸å¿ƒæ¶æ„

### åè®®è®¾è®¡åŸåˆ™

#### 1. æ ‡å‡†åŒ–æ¥å£
- **ç»Ÿä¸€APIè§„èŒƒ**ï¼šæ‰€æœ‰MCPå·¥å…·éƒ½éµå¾ªç›¸åŒçš„æ¥å£æ ‡å‡†
- **ç±»å‹ç³»ç»Ÿ**ï¼šå¼ºç±»å‹å‚æ•°å®šä¹‰å’ŒéªŒè¯æœºåˆ¶
- **ç‰ˆæœ¬å…¼å®¹**ï¼šå‘åå…¼å®¹çš„åè®®ç‰ˆæœ¬ç®¡ç†
- **æ–‡æ¡£é©±åŠ¨**ï¼šè‡ªæè¿°çš„å·¥å…·å…ƒæ•°æ®ç³»ç»Ÿ

#### 2. å®‰å…¨æ€§ä¼˜å…ˆ
- **æƒé™æ§åˆ¶**ï¼šç»†ç²’åº¦çš„è®¿é—®æƒé™ç®¡ç†
- **è¾“å…¥éªŒè¯**ï¼šä¸¥æ ¼çš„å‚æ•°ç±»å‹å’ŒèŒƒå›´æ£€æŸ¥
- **æ²™ç®±æ‰§è¡Œ**ï¼šéš”ç¦»çš„å·¥å…·æ‰§è¡Œç¯å¢ƒ
- **å®¡è®¡æ—¥å¿—**ï¼šå®Œæ•´çš„æ“ä½œè®°å½•å’Œè¿½è¸ª

#### 3. å¯æ‰©å±•æ€§
- **æ’ä»¶æ¶æ„**ï¼šåŠ¨æ€åŠ è½½å’Œå¸è½½å·¥å…·
- **è‡ªå®šä¹‰å·¥å…·**ï¼šæ”¯æŒç”¨æˆ·å¼€å‘ä¸“ç”¨å·¥å…·
- **åè®®æ‰©å±•**ï¼šå¯æ‰©å±•çš„åè®®æ¶ˆæ¯ç±»å‹
- **å¤šè¯­è¨€æ”¯æŒ**ï¼šè·¨å¹³å°çš„å·¥å…·å®ç°

## ğŸ”§ MCPåè®®æŠ€æœ¯è§„èŒƒ

### æ¶ˆæ¯æ ¼å¼å®šä¹‰

#### åŸºç¡€æ¶ˆæ¯ç»“æ„
```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "tool_name",
    "arguments": {
      "param1": "value1",
      "param2": "value2"
    }
  },
  "id": "request_id_123"
}
```

#### å·¥å…·æ³¨å†Œæ¶ˆæ¯
```json
{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "result": {
    "tools": [
      {
        "name": "file_read",
        "description": "Read content from a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "File path to read"
            }
          },
          "required": ["path"]
        }
      }
    ]
  }
}
```

### å‚æ•°ä¼ é€’æœºåˆ¶

#### ç¯å¢ƒå˜é‡æ˜ å°„
```bash
# MCPå‚æ•°é€šè¿‡ç¯å¢ƒå˜é‡ä¼ é€’
export MCP_PARAM_PATH="/Users/apple/documents/file.txt"
export MCP_PARAM_ENCODING="utf-8"
export MCP_PARAM_MAX_SIZE="1048576"

# å·¥å…·è„šæœ¬è¯»å–å‚æ•°
#!/bin/bash
INPUT_PATH="${MCP_PARAM_PATH}"
ENCODING="${MCP_PARAM_ENCODING:-utf-8}"
MAX_SIZE="${MCP_PARAM_MAX_SIZE:-1000000}"
```

#### ç±»å‹è½¬æ¢å¤„ç†
```javascript
// JavaScriptå·¥å…·ä¸­çš„å‚æ•°å¤„ç†
class MCPToolHandler {
    parseArguments(envVars) {
        const args = {};

        for (const [key, value] of Object.entries(envVars)) {
            if (key.startsWith('MCP_PARAM_')) {
                const paramName = key.replace('MCP_PARAM_', '').toLowerCase();

                // ç±»å‹è½¬æ¢
                if (value === 'true' || value === 'false') {
                    args[paramName] = value === 'true';
                } else if (!isNaN(value) && value !== '') {
                    args[paramName] = Number(value);
                } else {
                    args[paramName] = value;
                }
            }
        }

        return args;
    }
}
```

## ğŸ› ï¸ MCPå·¥å…·å¼€å‘å®è·µ

### Shellè„šæœ¬å·¥å…·å¼€å‘

#### å…ƒæ•°æ®æ ‡å‡†æ ¼å¼
```bash
#!/bin/bash
# @mcp.tool {"name":"file_analyzer","description":"Analyze file content and metadata"}
# @mcp.argument {"name":"file_path","type":"string","description":"Path to the file to analyze","required":true}
# @mcp.argument {"name":"analysis_type","type":"string","description":"Type of analysis (basic|detailed|security)","required":false,"default":"basic"}
# @mcp.argument {"name":"output_format","type":"string","description":"Output format (json|text|markdown)","required":false,"default":"json"}

set -euo pipefail

# å‚æ•°è·å–
FILE_PATH="${MCP_PARAM_FILE_PATH}"
ANALYSIS_TYPE="${MCP_PARAM_ANALYSIS_TYPE:-basic}"
OUTPUT_FORMAT="${MCP_PARAM_OUTPUT_FORMAT:-json}"

# è¾“å…¥éªŒè¯
if [ ! -f "$FILE_PATH" ](/tags/ ! -f "$FILE_PATH" /); then
    echo "ERROR: File not found: $FILE_PATH" >&2
    exit 1
fi

# æ ¸å¿ƒåŠŸèƒ½å®ç°
analyze_file() {
    local file="$1"
    local type="$2"
    local format="$3"

    case "$type" in
        "basic")
            basic_analysis "$file" "$format"
            ;;
        "detailed")
            detailed_analysis "$file" "$format"
            ;;
        "security")
            security_analysis "$file" "$format"
            ;;
        *)
            echo "ERROR: Unknown analysis type: $type" >&2
            exit 1
            ;;
    esac
}

basic_analysis() {
    local file="$1"
    local format="$2"

    local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    local mime_type=$(file -b --mime-type "$file")
    local modified=$(stat -f%m "$file" 2>/dev/null || stat -c%Y "$file" 2>/dev/null)

    if [ "$format" == "json" ](/tags/ "$format" == "json" /); then
        cat <<EOF
{
    "file_path": "$file",
    "size_bytes": $size,
    "mime_type": "$mime_type",
    "last_modified": $modified,
    "analysis_type": "$type"
}
EOF
    else
        echo "File: $file"
        echo "Size: $size bytes"
        echo "Type: $mime_type"
        echo "Modified: $(date -r $modified)"
    fi
}

# æ‰§è¡Œåˆ†æ
analyze_file "$FILE_PATH" "$ANALYSIS_TYPE" "$OUTPUT_FORMAT"
```

### Node.js MCPæœåŠ¡å™¨

#### æœåŠ¡å™¨å®ç°æ¡†æ¶
```javascript
// mcp-server.js - MCPæœåŠ¡å™¨å®ç°
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

class MCPToolServer {
    constructor() {
        this.server = new Server(
            {
                name: 'custom-tools-server',
                version: '1.0.0',
            },
            {
                capabilities: {
                    tools: {},
                },
            }
        );

        this.setupHandlers();
    }

    setupHandlers() {
        // å·¥å…·åˆ—è¡¨å¤„ç†
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
            return {
                tools: [
                    {
                        name: 'file_analyzer',
                        description: 'Analyze file content and metadata',
                        inputSchema: {
                            type: 'object',
                            properties: {
                                file_path: {
                                    type: 'string',
                                    description: 'Path to the file to analyze',
                                },
                                analysis_type: {
                                    type: 'string',
                                    enum: ['basic', 'detailed', 'security'],
                                    default: 'basic',
                                    description: 'Type of analysis to perform',
                                },
                                output_format: {
                                    type: 'string',
                                    enum: ['json', 'text', 'markdown'],
                                    default: 'json',
                                    description: 'Output format',
                                },
                            },
                            required: ['file_path'],
                        },
                    },
                ],
            };
        });

        // å·¥å…·è°ƒç”¨å¤„ç†
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;

            switch (name) {
                case 'file_analyzer':
                    return await this.handleFileAnalyzer(args);
                default:
                    throw new Error(`Unknown tool: ${name}`);
            }
        });
    }

    async handleFileAnalyzer(args) {
        const { file_path, analysis_type = 'basic', output_format = 'json' } = args;

        try {
            // è®¾ç½®ç¯å¢ƒå˜é‡
            process.env.MCP_PARAM_FILE_PATH = file_path;
            process.env.MCP_PARAM_ANALYSIS_TYPE = analysis_type;
            process.env.MCP_PARAM_OUTPUT_FORMAT = output_format;

            // æ‰§è¡Œå·¥å…·è„šæœ¬
            const { spawn } = await import('child_process');
            const { promisify } = await import('util');
            const exec = promisify(spawn);

            const result = await new Promise((resolve, reject) => {
                const child = spawn('./tools/file_analyzer.sh', [], {
                    stdio: ['pipe', 'pipe', 'pipe'],
                    env: process.env
                });

                let stdout = '';
                let stderr = '';

                child.stdout.on('data', (data) => {
                    stdout += data.toString();
                });

                child.stderr.on('data', (data) => {
                    stderr += data.toString();
                });

                child.on('close', (code) => {
                    if (code === 0) {
                        resolve(stdout);
                    } else {
                        reject(new Error(`Tool failed with code ${code}: ${stderr}`));
                    }
                });
            });

            return {
                content: [
                    {
                        type: 'text',
                        text: result,
                    },
                ],
            };
        } catch (error) {
            return {
                content: [
                    {
                        type: 'text',
                        text: `Error: ${error.message}`,
                    },
                ],
                isError: true,
            };
        }
    }

    async start() {
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
    }
}

// å¯åŠ¨æœåŠ¡å™¨
const server = new MCPToolServer();
server.start().catch(console.error);
```

## ğŸ” MCPå¼€å‘æœ€ä½³å®è·µ

### å·¥å…·è®¾è®¡åŸåˆ™

#### 1. å•ä¸€èŒè´£åŸåˆ™
```bash
# å¥½çš„è®¾è®¡ - ä¸“æ³¨å•ä¸€åŠŸèƒ½
#!/bin/bash
# @mcp.tool {"name":"git_status","description":"Get git repository status"}

# åçš„è®¾è®¡ - åŠŸèƒ½è¿‡äºå¤æ‚
#!/bin/bash
# @mcp.tool {"name":"git_everything","description":"Do all git operations"}
```

#### 2. é”™è¯¯å¤„ç†å®Œå¤‡æ€§
```bash
#!/bin/bash
# å®Œå–„çš„é”™è¯¯å¤„ç†ç¤ºä¾‹

set -euo pipefail  # ä¸¥æ ¼æ¨¡å¼

# å‚æ•°éªŒè¯
validate_inputs() {
    if [ -z "${MCP_PARAM_REPO_PATH:-}" ](/tags/ -z "${MCP_PARAM_REPO_PATH:-}" /); then
        echo "ERROR: repo_path parameter is required" >&2
        exit 1
    fi

    if [ ! -d "$MCP_PARAM_REPO_PATH" ](/tags/ ! -d "$MCP_PARAM_REPO_PATH" /); then
        echo "ERROR: Directory does not exist: $MCP_PARAM_REPO_PATH" >&2
        exit 1
    fi

    if [ ! -d "$MCP_PARAM_REPO_PATH/.git" ](/tags/ ! -d "$MCP_PARAM_REPO_PATH/.git" /); then
        echo "ERROR: Not a git repository: $MCP_PARAM_REPO_PATH" >&2
        exit 1
    fi
}

# ä¸»è¦åŠŸèƒ½
main() {
    validate_inputs

    cd "$MCP_PARAM_REPO_PATH" || {
        echo "ERROR: Cannot change to directory: $MCP_PARAM_REPO_PATH" >&2
        exit 1
    }

    # æ‰§è¡Œgitå‘½ä»¤å¹¶å¤„ç†å¯èƒ½çš„é”™è¯¯
    if ! git status --porcelain 2>/dev/null; then
        echo "ERROR: Failed to get git status" >&2
        exit 1
    fi
}

main "$@"
```

#### 3. è¾“å‡ºæ ‡å‡†åŒ–
```bash
# æ ‡å‡†åŒ–JSONè¾“å‡º
output_json() {
    local status="$1"
    local message="$2"
    local data="$3"

    cat <<EOF
{
    "status": "$status",
    "message": "$message",
    "timestamp": "$(date -Iseconds)",
    "data": $data
}
EOF
}

# ä½¿ç”¨ç¤ºä¾‹
if command_successful; then
    output_json "success" "Operation completed" "{\"result\": \"value\"}"
else
    output_json "error" "Operation failed" "null"
fi
```

### è°ƒè¯•å’Œæ•…éšœæ’é™¤

#### å¸¸è§é—®é¢˜è¯Šæ–­

**1. å…ƒæ•°æ®æ ¼å¼é”™è¯¯**
```bash
# é”™è¯¯ç¤ºä¾‹
# @mcp.argument {key:"param",description:"desc",required:true}  # ç¼ºå°‘å¼•å·

# æ­£ç¡®ç¤ºä¾‹
# @mcp.argument {"key":"param","description":"desc","required":true}
```

**2. å‚æ•°ä¼ é€’é—®é¢˜**
```bash
# è°ƒè¯•å‚æ•°ä¼ é€’
debug_params() {
    echo "=== MCP Parameters Debug ===" >&2
    env | grep "^MCP_PARAM_" >&2
    echo "===========================" >&2
}

# åœ¨å·¥å…·å¼€å§‹æ—¶è°ƒç”¨
debug_params
```

**3. éªŒè¯æµç¨‹**
```bash
# 5æ­¥éªŒè¯æ³•
echo "Step 1: Testing script directly..."
./your_tool.sh

echo "Step 2: Validating metadata..."
npm run inspect

echo "Step 3: Testing server..."
node dist/index.js --debug-render

echo "Step 4: Testing integration..."
claude mcp list

echo "Step 5: End-to-end test..."
# åœ¨Claude Codeä¸­å®é™…è°ƒç”¨å·¥å…·
```

## ğŸ“Š MCPç”Ÿæ€ç³»ç»Ÿé›†æˆ

### Claude Codeé›†æˆ

#### é…ç½®ç®¡ç†
```json
// ~/.claude/config.json - MCPæœåŠ¡å™¨é…ç½®
{
  "mcpServers": {
    "custom-tools": {
      "command": "node",
      "args": ["dist/index.js"],
      "cwd": "/path/to/mcp-server",
      "env": {
        "NODE_ENV": "production"
      }
    }
  }
}
```

#### å·¥å…·æ³¨å†Œæµç¨‹
```bash
# æ·»åŠ MCPæœåŠ¡å™¨
claude mcp add custom-tools node dist/index.js -- -p /full/path/.mcp_tools

# éªŒè¯æ³¨å†Œ
claude mcp list

# æµ‹è¯•è¿æ¥
claude mcp test custom-tools
```

### å¼€å‘ç¯å¢ƒé…ç½®

#### é¡¹ç›®ç»“æ„æ ‡å‡†
```
mcp-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.js              # ä¸»æœåŠ¡å™¨æ–‡ä»¶
â”‚   â”œâ”€â”€ tools/                # å·¥å…·å®ç°ç›®å½•
â”‚   â”‚   â”œâ”€â”€ file_analyzer.sh  # Shellå·¥å…·
â”‚   â”‚   â””â”€â”€ git_helper.py     # Pythonå·¥å…·
â”‚   â””â”€â”€ lib/
â”‚       â”œâ”€â”€ validation.js     # å‚æ•°éªŒè¯
â”‚       â””â”€â”€ utils.js          # é€šç”¨å·¥å…·
â”œâ”€â”€ dist/                     # ç¼–è¯‘è¾“å‡º
â”œâ”€â”€ tests/                    # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ .mcp_tools/              # MCPå·¥å…·å…ƒæ•°æ®
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

#### è‡ªåŠ¨åŒ–æµ‹è¯•
```javascript
// tests/mcp-tools.test.js
import { spawn } from 'child_process';
import { promisify } from 'util';

describe('MCP Tools Integration', () => {
    test('file_analyzer tool execution', async () => {
        process.env.MCP_PARAM_FILE_PATH = './test-file.txt';
        process.env.MCP_PARAM_ANALYSIS_TYPE = 'basic';

        const result = await new Promise((resolve, reject) => {
            const child = spawn('./src/tools/file_analyzer.sh');
            let output = '';

            child.stdout.on('data', (data) => {
                output += data.toString();
            });

            child.on('close', (code) => {
                if (code === 0) {
                    resolve(JSON.parse(output));
                } else {
                    reject(new Error(`Tool failed with code ${code}`));
                }
            });
        });

        expect(result.status).toBe('success');
        expect(result.data).toHaveProperty('file_path');
    });
});
```

## ğŸš€ é«˜çº§ç‰¹æ€§ä¸æ‰©å±•

### æµå¼å¤„ç†æ”¯æŒ

#### å¤§æ•°æ®å¤„ç†å·¥å…·
```bash
#!/bin/bash
# @mcp.tool {"name":"log_analyzer","description":"Analyze large log files with streaming"}
# @mcp.argument {"name":"log_file","type":"string","description":"Path to log file","required":true}
# @mcp.argument {"name":"pattern","type":"string","description":"Search pattern","required":true}
# @mcp.argument {"name":"stream_size","type":"number","description":"Stream buffer size","required":false,"default":1000}

LOG_FILE="${MCP_PARAM_LOG_FILE}"
PATTERN="${MCP_PARAM_PATTERN}"
STREAM_SIZE="${MCP_PARAM_STREAM_SIZE:-1000}"

# æµå¼å¤„ç†å¤§æ–‡ä»¶
stream_analyze() {
    local line_count=0
    local match_count=0

    while IFS= read -r line; do
        ((line_count++))

        if [ "$line" =~ $PATTERN ](/tags/ "$line" =~ $PATTERN /); then
            ((match_count++))
            echo "{\"line\":$line_count,\"match\":\"$(echo "$line" | jq -R .)\",\"timestamp\":\"$(date -Iseconds)\"}"
        fi

        # å®šæœŸè¾“å‡ºè¿›åº¦
        if (( line_count % STREAM_SIZE == 0 )); then
            echo "{\"progress\":$line_count,\"matches\":$match_count,\"status\":\"processing\"}" >&2
        fi
    done < "$LOG_FILE"

    echo "{\"total_lines\":$line_count,\"total_matches\":$match_count,\"status\":\"completed\"}" >&2
}

stream_analyze
```

### å¼‚æ­¥æ“ä½œå¤„ç†

#### åå°ä»»åŠ¡ç®¡ç†
```javascript
// async-tool-handler.js
class AsyncToolHandler {
    constructor() {
        this.runningTasks = new Map();
    }

    async startAsyncTool(toolName, args) {
        const taskId = `${toolName}_${Date.now()}`;

        const task = this.executeAsyncTool(toolName, args);
        this.runningTasks.set(taskId, {
            promise: task,
            startTime: Date.now(),
            status: 'running'
        });

        // å¼‚æ­¥å¤„ç†ç»“æœ
        task.then(result => {
            this.runningTasks.get(taskId).status = 'completed';
            this.runningTasks.get(taskId).result = result;
        }).catch(error => {
            this.runningTasks.get(taskId).status = 'failed';
            this.runningTasks.get(taskId).error = error.message;
        });

        return {
            taskId,
            message: 'Task started successfully',
            estimatedTime: this.getEstimatedTime(toolName, args)
        };
    }

    getTaskStatus(taskId) {
        const task = this.runningTasks.get(taskId);
        if (!task) {
            return { error: 'Task not found' };
        }

        return {
            taskId,
            status: task.status,
            runtime: Date.now() - task.startTime,
            result: task.result,
            error: task.error
        };
    }
}
```

## ğŸ”’ å®‰å…¨æ€§ä¸æƒé™ç®¡ç†

### å®‰å…¨é…ç½®æœ€ä½³å®è·µ

#### æƒé™æ§åˆ¶é…ç½®
```json
{
  "security": {
    "allowedPaths": [
      "/Users/apple/Work/personal/obsidian",
      "/tmp/mcp-temp"
    ],
    "blockedPaths": [
      "/System",
      "/usr/bin",
      "~/.ssh"
    ],
    "allowedCommands": [
      "git",
      "npm",
      "node"
    ],
    "maxFileSize": "100MB",
    "timeout": "300s"
  }
}
```

#### è¾“å…¥éªŒè¯æ¡†æ¶
```bash
# security-validation.sh - å®‰å…¨éªŒè¯åº“

validate_path() {
    local path="$1"
    local allowed_patterns=(
        "/Users/apple/Work/personal/obsidian/*"
        "/tmp/mcp-temp/*"
    )

    local blocked_patterns=(
        "/System/*"
        "/usr/bin/*"
        "*/.*ssh*"
        "*/.git/config"
    )

    # æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨å…è®¸åˆ—è¡¨ä¸­
    for pattern in "${allowed_patterns[@]}"; do
        if [ "$path" == $pattern ](/tags/ "$path" == $pattern /); then
            return 0
        fi
    done

    # æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨é˜»æ­¢åˆ—è¡¨ä¸­
    for pattern in "${blocked_patterns[@]}"; do
        if [ "$path" == $pattern ](/tags/ "$path" == $pattern /); then
            echo "ERROR: Access denied to blocked path: $path" >&2
            return 1
        fi
    done

    echo "ERROR: Path not in allowed list: $path" >&2
    return 1
}

validate_command() {
    local cmd="$1"
    local allowed_commands=("git" "npm" "node" "cat" "grep" "find")

    for allowed in "${allowed_commands[@]}"; do
        if [ "$cmd" == "$allowed" ](/tags/ "$cmd" == "$allowed" /); then
            return 0
        fi
    done

    echo "ERROR: Command not allowed: $cmd" >&2
    return 1
}
```

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ç¼“å­˜æœºåˆ¶å®ç°

#### ç»“æœç¼“å­˜ç³»ç»Ÿ
```javascript
// cache-manager.js
class MCPCacheManager {
    constructor(options = {}) {
        this.cache = new Map();
        this.maxSize = options.maxSize || 1000;
        this.ttl = options.ttl || 3600000; // 1 hour
    }

    generateKey(toolName, args) {
        return `${toolName}:${JSON.stringify(args)}`;
    }

    get(toolName, args) {
        const key = this.generateKey(toolName, args);
        const cached = this.cache.get(key);

        if (!cached) return null;

        if (Date.now() - cached.timestamp > this.ttl) {
            this.cache.delete(key);
            return null;
        }

        return cached.data;
    }

    set(toolName, args, data) {
        const key = this.generateKey(toolName, args);

        // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®
        if (this.cache.size >= this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    clear() {
        this.cache.clear();
    }
}
```

### å¹¶å‘å¤„ç†ä¼˜åŒ–

#### å·¥å…·æ± ç®¡ç†
```javascript
// tool-pool.js
class MCPToolPool {
    constructor(maxConcurrent = 10) {
        this.maxConcurrent = maxConcurrent;
        this.running = new Set();
        this.queue = [];
    }

    async execute(toolFunction, ...args) {
        return new Promise((resolve, reject) => {
            this.queue.push({ toolFunction, args, resolve, reject });
            this.processQueue();
        });
    }

    async processQueue() {
        if (this.running.size >= this.maxConcurrent || this.queue.length === 0) {
            return;
        }

        const { toolFunction, args, resolve, reject } = this.queue.shift();
        const taskId = Symbol('task');

        this.running.add(taskId);

        try {
            const result = await toolFunction(...args);
            resolve(result);
        } catch (error) {
            reject(error);
        } finally {
            this.running.delete(taskId);
            this.processQueue(); // å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
        }
    }
}
```

## ğŸ“š å®è·µæ¡ˆä¾‹ç ”ç©¶

### æ¡ˆä¾‹1ï¼šæ–‡ä»¶ç³»ç»Ÿå·¥å…·å¥—ä»¶

#### å·¥å…·è®¾è®¡
```bash
#!/bin/bash
# @mcp.tool {"name":"fs_operations","description":"Comprehensive file system operations"}
# @mcp.argument {"name":"operation","type":"string","description":"Operation type (list|read|write|delete|copy|move)","required":true}
# @mcp.argument {"name":"path","type":"string","description":"Target path","required":true}
# @mcp.argument {"name":"content","type":"string","description":"Content for write operations","required":false}
# @mcp.argument {"name":"destination","type":"string","description":"Destination for copy/move operations","required":false}

source ./lib/security-validation.sh

OPERATION="${MCP_PARAM_OPERATION}"
PATH="${MCP_PARAM_PATH}"
CONTENT="${MCP_PARAM_CONTENT:-}"
DESTINATION="${MCP_PARAM_DESTINATION:-}"

# éªŒè¯è·¯å¾„å®‰å…¨æ€§
validate_path "$PATH" || exit 1

case "$OPERATION" in
    "list")
        ls -la "$PATH" | jq -R -s 'split("\n")[1:-1] | map(split(" ") | {permissions: .[0], size: .[4], name: .[8]})'
        ;;
    "read")
        if [ -f "$PATH" ](/tags/ -f "$PATH" /); then
            cat "$PATH" | jq -R -s '.'
        else
            echo '{"error": "File not found or not readable"}' >&2
            exit 1
        fi
        ;;
    "write")
        if [ -n "$CONTENT" ](/tags/ -n "$CONTENT" /); then
            echo "$CONTENT" > "$PATH"
            echo '{"status": "success", "message": "File written successfully"}'
        else
            echo '{"error": "Content parameter required for write operation"}' >&2
            exit 1
        fi
        ;;
    *)
        echo '{"error": "Unknown operation"}' >&2
        exit 1
        ;;
esac
```

### æ¡ˆä¾‹2ï¼šå¼€å‘å·¥å…·é›†æˆ

#### Gité›†æˆå·¥å…·
```python
#!/usr/bin/env python3
# @mcp.tool {"name":"git_assistant","description":"Advanced git operations assistant"}
# @mcp.argument {"name":"command","type":"string","description":"Git command (status|log|diff|commit|push|pull)","required":true}
# @mcp.argument {"name":"repository","type":"string","description":"Repository path","required":true}
# @mcp.argument {"name":"options","type":"string","description":"Additional options","required":false}

import os
import sys
import json
import subprocess
from pathlib import Path

def validate_repository(repo_path):
    """éªŒè¯ä»“åº“è·¯å¾„"""
    path = Path(repo_path)
    if not path.exists():
        raise Exception(f"Repository path does not exist: {repo_path}")
    if not (path / '.git').exists():
        raise Exception(f"Not a git repository: {repo_path}")
    return str(path.resolve())

def execute_git_command(command, repo_path, options=""):
    """æ‰§è¡Œgitå‘½ä»¤"""
    os.chdir(repo_path)

    cmd_map = {
        'status': ['git', 'status', '--porcelain', '-b'],
        'log': ['git', 'log', '--oneline', '-10'],
        'diff': ['git', 'diff', '--stat'],
        'commit': ['git', 'commit', '-m', options or 'Auto commit via MCP'],
        'push': ['git', 'push'],
        'pull': ['git', 'pull']
    }

    if command not in cmd_map:
        raise Exception(f"Unknown git command: {command}")

    result = subprocess.run(
        cmd_map[command],
        capture_output=True,
        text=True,
        timeout=30
    )

    return {
        'command': ' '.join(cmd_map[command]),
        'returncode': result.returncode,
        'stdout': result.stdout,
        'stderr': result.stderr,
        'success': result.returncode == 0
    }

def main():
    try:
        command = os.getenv('MCP_PARAM_COMMAND')
        repository = os.getenv('MCP_PARAM_REPOSITORY')
        options = os.getenv('MCP_PARAM_OPTIONS', '')

        if not command or not repository:
            raise Exception("command and repository parameters are required")

        repo_path = validate_repository(repository)
        result = execute_git_command(command, repo_path, options)

        print(json.dumps(result, indent=2))

    except Exception as e:
        error_result = {
            'error': str(e),
            'success': False
        }
        print(json.dumps(error_result, indent=2), file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
```

## ğŸ“ å­¦ä¹ èµ„æºä¸ç¤¾åŒº

### å®˜æ–¹èµ„æº
- **MCPåè®®è§„èŒƒ**ï¼šè¯¦ç»†çš„åè®®æ–‡æ¡£å’ŒAPIå‚è€ƒ
- **SDKæ–‡æ¡£**ï¼šå¤šè¯­è¨€SDKä½¿ç”¨æŒ‡å—
- **ç¤ºä¾‹é¡¹ç›®**ï¼šå®˜æ–¹ç»´æŠ¤çš„å·¥å…·ç¤ºä¾‹
- **æœ€ä½³å®è·µæŒ‡å—**ï¼šç»è¿‡éªŒè¯çš„å¼€å‘æ¨¡å¼

### ç¤¾åŒºç”Ÿæ€
- **å·¥å…·ä»“åº“**ï¼šç¤¾åŒºè´¡çŒ®çš„MCPå·¥å…·é›†åˆ
- **å¼€å‘è€…è®ºå›**ï¼šæŠ€æœ¯è®¨è®ºå’Œé—®é¢˜è§£ç­”
- **æ’ä»¶å¸‚åœº**ï¼šç¬¬ä¸‰æ–¹å·¥å…·å’Œæ‰©å±•
- **åŸ¹è®­èµ„æº**ï¼šåœ¨çº¿è¯¾ç¨‹å’Œå·¥ä½œåŠ

### å¼€å‘è·¯çº¿å›¾
```markdown
# MCPåè®®å‘å±•è·¯çº¿å›¾

## å½“å‰ç‰ˆæœ¬ 1.0
- âœ… åŸºç¡€åè®®è§„èŒƒ
- âœ… JSON-RPC 2.0æ”¯æŒ
- âœ… å·¥å…·æ³¨å†Œå’Œè°ƒç”¨
- âœ… åŸºç¡€å®‰å…¨æœºåˆ¶

## ç‰ˆæœ¬ 1.1 (è§„åˆ’ä¸­)
- ğŸ”„ æµå¼æ•°æ®æ”¯æŒ
- ğŸ”„ å¼‚æ­¥æ“ä½œå¢å¼º
- ğŸ”„ æ‰¹é‡æ“ä½œæ¥å£
- ğŸ”„ é«˜çº§ç¼“å­˜æœºåˆ¶

## ç‰ˆæœ¬ 2.0 (æœªæ¥)
- ğŸ“… åˆ†å¸ƒå¼å·¥å…·è°ƒç”¨
- ğŸ“… æ™ºèƒ½å·¥å…·æ¨è
- ğŸ“… è‡ªåŠ¨å·¥å…·ç»„åˆ
- ğŸ“… å¤šæ¨¡æ€æ”¯æŒ
```

## ç›¸å…³é“¾æ¥

- [AIå¼€å‘å·¥å…·ç”Ÿæ€](/tags/AIå¼€å‘å·¥å…·ç”Ÿæ€/)
- [Claude Codeå®è·µ](/tags/Claude Codeå®è·µ/)
- [APIè®¾è®¡æœ€ä½³å®è·µ](/tags/APIè®¾è®¡æœ€ä½³å®è·µ/)
- [JSON-RPCåè®®](/tags/JSON-RPCåè®®/)
- [å·¥å…·é›†æˆæ¶æ„](/tags/å·¥å…·é›†æˆæ¶æ„/)
- [å®‰å…¨ç¼–ç¨‹å®è·µ](/tags/å®‰å…¨ç¼–ç¨‹å®è·µ/)

---

**ğŸ’¡ æ ¸å¿ƒæ´å¯Ÿ**: MCPåè®®æ˜¯AIå·¥å…·ç”Ÿæ€çš„é‡è¦åŸºç¡€è®¾æ–½ï¼Œå®ƒæ ‡å‡†åŒ–äº†AIä¸å¤–éƒ¨å·¥å…·çš„äº¤äº’æ–¹å¼ï¼Œä½¿å¾—AIåº”ç”¨èƒ½å¤Ÿå®‰å…¨ã€é«˜æ•ˆåœ°æ‰©å±•åŠŸèƒ½è¾¹ç•Œã€‚åè®®çš„è®¾è®¡ä½“ç°äº†å®‰å…¨æ€§ã€å¯æ‰©å±•æ€§å’Œæ˜“ç”¨æ€§çš„å¹³è¡¡ï¼Œä¸ºæ„å»ºå¤æ‚çš„AI Agentç³»ç»Ÿæä¾›äº†åšå®åŸºç¡€ã€‚æŒæ¡MCPåè®®çš„å¼€å‘å’Œè°ƒè¯•æŠ€å·§ï¼Œæ˜¯ç°ä»£AIåº”ç”¨å¼€å‘è€…çš„å¿…å¤‡æŠ€èƒ½ã€‚